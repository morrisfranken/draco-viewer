<!DOCTYPE html>
<html>
<head>
    <title>Draco Viewer</title>
    <link rel="icon" type="image/png" href="drc-viewer.png">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; /* Hide scrollbars */
            background-color: #282c34; /* Match scene background for loading */
            font-family: sans-serif;
            color: #eee;
        }
        canvas { display: block; }
        #loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
            text-align: center;
            min-width: 250px;
        }
        #loading-text {
            font-size: 18px;
            margin-bottom: 10px;
        }
        #progress-bar-container {
            width: 100%;
            background-color: #555;
            border-radius: 4px;
            height: 20px;
            overflow: hidden; /* Ensures inner bar respects border-radius */
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            border-radius: 4px;
            transition: width 0.1s ease-out;
        }
        #drop-zone-text {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 16px;
            display: none; /* Hidden by default, shown on drag over */
        }
        #controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(40, 40, 50, 0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 50;
            color: #f0f0f0;
        }
        #controls-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        #controls-panel label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        #controls-panel input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }
        #model-info-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(40, 40, 50, 0.75);
            padding: 8px 12px;
            border-radius: 6px;
            z-index: 60;
            color: #e0e0e0;
            font-size: 14px;
            display: none; /* Hidden until a model is loaded */
            max-width: calc(100vw - 250px); /* Avoid overlapping with controls panel */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

    </style>
</head>
<body>
    <div id="loading-container">
        <div id="loading-text">Loading model...</div>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
    </div>
    <div id="drop-zone-text">Drop .drc file here</div>

    <div id="model-info-container">
        Current Model: <span id="current-model-name"></span>
    </div>

    <div id="controls-panel" style="display: none;"> <!-- Hidden until model loads -->
        <h3>Viewer Controls</h3>
        <label><input type="checkbox" id="toggle-ground" checked> Ground Plane</label>
        <label><input type="checkbox" id="toggle-wireframe"> Wireframe</label>
        <label><input type="checkbox" id="toggle-backfaceculling" checked> Backface Culling</label>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, directionalLight, modelMesh, groundPlane;
        const loadingContainer = document.getElementById('loading-container');
        const loadingText = document.getElementById('loading-text');
        const progressBar = document.getElementById('progress-bar');
        const dropZoneText = document.getElementById('drop-zone-text');
        const controlsPanel = document.getElementById('controls-panel');
        const modelInfoContainer = document.getElementById('model-info-container');
        const currentModelNameSpan = document.getElementById('current-model-name');

        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        dracoLoader.setDecoderConfig({ type: 'js' }); // Consider 'wasm' for better performance

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x282c34);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false; // Disable shadow mapping
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
            controls.screenSpacePanning = false;
            controls.addEventListener('change', renderScene);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.9);
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            // Ground Plane
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x404040,
                roughness: 0.8,
                metalness: 0.2
            });
            groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                groundMaterial
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -1;
            scene.add(groundPlane);

            setupDragAndDrop();
            setupUIControls();

            // Electron: Listen for file path from main process
            if (window.electronAPI && typeof window.electronAPI.onLoadFile === 'function') {
                window.electronAPI.onLoadFile(async (filePath) => {
                    console.log('Renderer process: Received file path via IPC:', filePath);
                    document.title = `Draco Viewer - ${filePath.split(/[/\\]/).pop()}`;
                    updateLoadingProgress(`Reading file: ${filePath}...`, 0);
                    try {
                        console.log('Renderer process: Requesting file content for:', filePath);
                        const result = await window.electronAPI.readFileContent(filePath);
                        console.log('Renderer process: Received result from readFileContent for:', filePath, 'Success:', result.success);

                        if (result.success && result.data) {
                            // result.data is a Buffer (or Uint8Array behaving like one) from the main process.
                            // DRACOLoader.parse expects an ArrayBuffer.
                            // Convert Node Buffer/Uint8Array to ArrayBuffer.
                            const receivedBuffer = result.data; // This is a Uint8Array/Buffer
                            const arrayBuffer = receivedBuffer.buffer.slice(
                                receivedBuffer.byteOffset,
                                receivedBuffer.byteOffset + receivedBuffer.byteLength
                            );
                            console.log('Renderer process: File content read and converted to ArrayBuffer, length:', arrayBuffer.byteLength);
                            loadDracoModel(arrayBuffer, filePath); // Pass ArrayBuffer and full path
                        } else {
                            showError(`Error reading file content: ${result.error || 'Unknown error'}`);
                        }
                    } catch (error) {
                        console.error('Renderer process: Error in onLoadFile processing:', error);
                        showError(`Error processing file: ${error.message}`);
                    }
                });
                // Initial message for Electron if no file is passed on startup
                // This check needs to be robust enough if onLoadFile is async and modelMesh might not be set yet.
                // A slight delay or a flag could be used, but for now, this assumes onLoadFile would execute quickly if a file was passed.
                setTimeout(() => { // Add a small delay to allow initial IPC to potentially load a model
                    if (!modelMesh) {
                        updateLoadingProgress('Open a .drc file or drag & drop one here.', 0);
                    }
                }, 100);

            } else {
                // Fallback for non-Electron environment (e.g. browser serving the page)
                console.warn("Electron API not found. Running in browser mode. Please drag & drop a .drc file.");
                updateLoadingProgress('Drag & drop a .drc model to view.', 0);
                // Do not attempt to load a default model from a relative path.
                // The loading indicator will stay until a file is dropped.
            }

            window.addEventListener('resize', onWindowResize, false);
        }

        function updateLoadingProgress(text, percentage) {
            loadingContainer.style.display = 'block';
            loadingText.innerText = text;
            progressBar.style.width = percentage + '%';
        }

        function hideLoadingIndicator() {
            loadingContainer.style.display = 'none';
            controlsPanel.style.display = 'block';
            // modelInfoContainer display is handled by loadDracoModel's onLoad
        }

        function showError(message) {
            loadingContainer.style.display = 'block'; // Ensure loading container is visible for errors
            loadingText.innerText = message;
            progressBar.style.width = '0%';
            progressBar.style.backgroundColor = '#F44336'; // Optional: Error color for progress bar
            console.error(message);
            controlsPanel.style.display = 'none';
            modelInfoContainer.style.display = 'none';
        }
        
        function clearScene() {
            if (modelMesh) {
                scene.remove(modelMesh);
                modelMesh.geometry.dispose();
                modelMesh.material.dispose();
                modelMesh = null;
            }
            modelInfoContainer.style.display = 'none';
            currentModelNameSpan.textContent = '';
            currentModelNameSpan.title = ''; // Clear tooltip
            document.title = "Draco Viewer";
        }

        function loadDracoModel(source, displayInfo) { // displayInfo is now full path or filename
            clearScene();
            progressBar.style.backgroundColor = '#4CAF50'; // Reset progress bar color on new load
            
            const loadingMessage = displayInfo ? `Preparing to load ${displayInfo.split(/[/\\]/).pop()}...` : 'Preparing to load...';
            updateLoadingProgress(loadingMessage, 0);

            // Set page title based on displayInfo if it's likely a filename, or a generic part of it
            if(displayInfo) {
                let titleName = displayInfo;
                if (displayInfo.includes('/')) { // If it's a path
                    titleName = displayInfo.split('/').pop(); // Get basename for title
                }
                document.title = `Draco Viewer - ${titleName}`;
            }

            const onLoad = function (geometry) {
                updateLoadingProgress('Decoding complete. Building scene...', 100);
                
                setTimeout(() => {
                    if (!geometry) { // Should be caught by parse's error callback, but as a safeguard
                        showError("Failed to decode model: Geometry is null.");
                        if (dracoLoader) dracoLoader.dispose();
                        return;
                    }
                    geometry.computeVertexNormals();
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xd1d1d1,
                        metalness: 0.1,
                        roughness: 0.5,
                        side: document.getElementById('toggle-backfaceculling').checked ? THREE.FrontSide : THREE.DoubleSide,
                        wireframe: document.getElementById('toggle-wireframe').checked
                    });
                    modelMesh = new THREE.Mesh(geometry, material);
                    scene.add(modelMesh);

                    geometry.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geometry.boundingBox.getCenter(center);
                    modelMesh.position.sub(center);

                    const size = new THREE.Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDimInitial = Math.max(size.x, size.y, size.z) || 1;
                    const scaleFactor = 2 / maxDimInitial;
                    modelMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    modelMesh.updateMatrixWorld(true);

                    const box = new THREE.Box3().setFromObject(modelMesh);
                    const modelSize = new THREE.Vector3();
                    box.getSize(modelSize);
                    const modelCenter = new THREE.Vector3();
                    box.getCenter(modelCenter);

                    groundPlane.position.y = box.min.y;
                    groundPlane.visible = document.getElementById('toggle-ground').checked;

                    controls.target.copy(modelCenter);

                    const fov = camera.fov * (Math.PI / 180);
                    const effectiveModelSize = Math.max(modelSize.x, modelSize.y, modelSize.z) || 1;
                    const distance = (effectiveModelSize / 2) / Math.tan(fov / 2);

                    camera.position.set(
                        modelCenter.x,
                        modelCenter.y + effectiveModelSize * 0.3,
                        modelCenter.z + distance * 1.5
                    );
                    camera.lookAt(modelCenter);

                    controls.minDistance = effectiveModelSize / 10;
                    controls.maxDistance = effectiveModelSize * 10;
                    controls.update();

                    directionalLight.target = modelMesh;
                    
                    hideLoadingIndicator();
                    if (displayInfo) {
                        currentModelNameSpan.textContent = displayInfo;
                        currentModelNameSpan.title = displayInfo; // Set tooltip to the full info
                        modelInfoContainer.style.display = 'block';
                    } else if (typeof source === 'string' && source !== '_active_model.drc') {
                        // Fallback for direct URL or default model if displayInfo wasn't explicitly passed
                        currentModelNameSpan.textContent = source;
                        currentModelNameSpan.title = source;
                        modelInfoContainer.style.display = 'block';
                    } else {
                        modelInfoContainer.style.display = 'none';
                    }
                    renderScene();
                }, 10);
            };

            const onProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    const percentComplete = xhr.loaded / xhr.total * 100;
                    updateLoadingProgress(`Downloading model... (${Math.round(percentComplete)}%)`, percentComplete);
                } else {
                    updateLoadingProgress('Downloading model... (progress unknown)', 0); // Or some indeterminate state
                }
            };
            
            const onError = function (error) {
                // Simplified error handling
                let errorMessage = 'Error loading Draco model.';
                if (error instanceof Error) {
                    errorMessage += ` ${error.message}`;
                } else if (typeof error === 'string') {
                    errorMessage += ` ${error}`;
                } else if (error && error.target && error.target.statusText && error.target.status !== 200) {
                    errorMessage += ` Network error: ${error.target.status} ${error.target.statusText}`;
                } else {
                    errorMessage += ` An unknown error occurred.`;
                }
                console.error('DracoLoader error details:', error);
                showError(errorMessage);
                if (dracoLoader) dracoLoader.dispose();
            };

            if (typeof source === 'string' && source.trim() !== '') { // Ensure source is not empty
                updateLoadingProgress(`Downloading ${displayInfo ? displayInfo.split(/[/\\]/).pop() : source}...`, 0);
                const cacheBustedSource = source + '?v=' + new Date().getTime();
                dracoLoader.load(cacheBustedSource, onLoad, onProgress, 
                    (err) => {
                        console.error('DracoLoader.load error:', err);
                        onError(err); // Pass the actual error object
                    }
                );
            } else if (source instanceof ArrayBuffer) {
                updateLoadingProgress('Decoding model from file...', 50);
                try {
                    // Correctly use dracoLoader.parse with callbacks
                    dracoLoader.parse(
                        source,
                        function (geometry) { // Success callback
                            if (geometry) {
                                onLoad(geometry);
                            } else {
                                onError(new Error("DRACOLoader.parse returned null or invalid geometry."));
                            }
                        },
                        function (error) { // Error callback
                            console.error('DracoLoader.parse error:', error);
                            onError(error || new Error("DRACOLoader.parse failed."));
                        }
                    );
                } catch (e) {
                    // This catch is a fallback, most errors should be caught by parse's error callback
                    console.error('Unexpected error during dracoLoader.parse setup:', e);
                    onError(e);
                } finally {
                    // Ensure dispose is called if dracoLoader was used for parsing
                    // For .load(), dispose is handled internally or if an error occurs.
                    // For .parse(), we need to manage it.
                    if (dracoLoader && source instanceof ArrayBuffer) {
                         dracoLoader.dispose();
                    }
                }
            } else if (!source) {
                showError("No model source provided to loadDracoModel.");
            }
        }

        function setupDragAndDrop() {
            const body = document.body;
            body.addEventListener('dragover', function(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
                dropZoneText.style.display = 'block';
                body.style.backgroundColor = '#3a3f4a';
            });

            body.addEventListener('dragleave', function(event) {
                dropZoneText.style.display = 'none';
                body.style.backgroundColor = '#282c34';
            });

            body.addEventListener('drop', function(event) {
                event.preventDefault();
                dropZoneText.style.display = 'none';
                body.style.backgroundColor = '#282c34';

                if (event.dataTransfer.files.length > 0) {
                    const file = event.dataTransfer.files[0];
                    if (file.name.toLowerCase().endsWith('.drc')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const droppedFilename = file.name;
                            // For drag-and-drop, we only have the filename
                            document.title = `Draco Viewer - ${droppedFilename}`;
                            updateLoadingProgress(`Loading ${droppedFilename}...`, 0); // Show loading message for dropped file
                            loadDracoModel(e.target.result, droppedFilename); 
                        };
                        reader.onerror = function(e) {
                            showError('Error reading dropped file.');
                        }
                        reader.readAsArrayBuffer(file);
                    } else {
                        showError('Please drop a .drc file.');
                    }
                }
            });
        }

        function setupUIControls() {
            const toggleGround = document.getElementById('toggle-ground');
            const toggleWireframe = document.getElementById('toggle-wireframe');
            const toggleBackfaceCulling = document.getElementById('toggle-backfaceculling');

            toggleGround.addEventListener('change', function() {
                groundPlane.visible = this.checked;
                renderScene();
            });

            toggleWireframe.addEventListener('change', function() {
                if (modelMesh) {
                    modelMesh.material.wireframe = this.checked;
                    renderScene();
                }
            });
            
            toggleBackfaceCulling.addEventListener('change', function() {
                if (modelMesh) {
                    modelMesh.material.side = this.checked ? THREE.FrontSide : THREE.DoubleSide;
                    modelMesh.material.needsUpdate = true;
                    renderScene();
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderScene();
        }

        function renderScene() {
            if (directionalLight && camera) {
                directionalLight.position.copy(camera.position);
                if (directionalLight.target && directionalLight.target !== scene) {
                     directionalLight.target.updateMatrixWorld();
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>