<!DOCTYPE html>
<html>
<head>
    <title>Draco Viewer</title>
    <link rel="icon" type="image/png" href="drc-viewer.png">
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: #1e2228; /* Darker background for more professional look */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font */
            color: #eee;
        }
        canvas { display: block; }
        
        /* Improved loading container */
        #loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 22, 26, 0.9);
            padding: 25px;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            border: 1px solid #363c46;
        }
        
        #loading-text {
            font-size: 18px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        
        /* Welcome message styling */
        #loading-text h3 {
            font-size: 24px;
            margin: 0 0 20px 0;
            color: #fff;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        
        .supported-formats {
            font-size: 18px;
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .format {
            display: inline-block;
            background: linear-gradient(135deg, #4776e6, #8e54e9);
            padding: 5px 12px;
            border-radius: 20px;
            margin: 5px 5px;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .format-info {
            color: #aab2c0;
            font-size: 14px;
            margin-top: 10px;
            font-style: italic;
        }
        
        #progress-bar-container {
            width: 100%;
            background-color: #2c3038;
            border-radius: 6px;
            height: 10px;
            overflow: hidden;
        }
        
        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4776e6, #8e54e9); /* Gradient progress bar */
            border-radius: 6px;
            transition: width 0.1s ease-out;
        }
        
        #drop-zone-text {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ccc;
            font-size: 16px;
            display: none; /* Hidden by default, shown on drag over */
            background-color: rgba(20, 22, 26, 0.7);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px dashed #666;
        }
        
        /* Improved controls panel */
        #controls-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(20, 22, 26, 0.85);
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 50;
            color: #f0f0f0;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            border: 1px solid #363c46;
            backdrop-filter: blur(5px);
            max-height: calc(100vh - 30px);
            overflow-y: auto;
            width: 240px;
        }
        
        #controls-panel h3 {
            margin-top: 0;
            margin-bottom: 15px; /* Adjusted if header is flex */
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
            font-weight: 500;
            flex-grow: 1; /* Allow h3 to take space */
        }

        #controls-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* margin-bottom: 10px; /* Replaced by h3 margin or padding on content */
        }

        #toggle-controls-panel-collapse {
            background: none;
            border: 1px solid #555;
            color: #eee;
            /* padding: 4px 10px; */ /* Adjusted for icon */
            padding: 5px;
            width: 28px; /* Fixed size for icon button */
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            /* font-size: 12px; */ /* No text */
            margin-left: 10px;
            flex-shrink: 0;
            transition: transform 0.2s ease-in-out; /* For arrow rotation */
        }

        #toggle-controls-panel-collapse svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            transition: transform 0.2s ease-in-out;
        }

        #toggle-controls-panel-collapse.collapsed svg {
            transform: rotate(-180deg); /* Rotate arrow when collapsed */
        }

        #controls-panel-content.collapsed {
            display: none;
        }

        .control-section {
            margin-bottom: 18px;
            padding-bottom: 18px;
            border-bottom: 1px solid #333;
        }

        .control-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        #controls-panel select {
            background-color: #2c3038;
            color: #fff;
            border: 1px solid #454955;
            border-radius: 4px;
            padding: 5px 8px;
            width: 100%;
            font-size: 13px;
            margin-top: 5px;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
        }
        
        #controls-panel input[type="range"] {
            width: 100%;
            margin-top: 5px;
            background: #2c3038;
            height: 5px;
            border-radius: 5px;
            appearance: none;
            accent-color: #8e54e9;
        }
        
        #controls-panel input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #8e54e9;
            cursor: pointer;
        }
        
        #controls-panel input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            background: none;
            padding: 0;
            margin-right: 10px;
            cursor: pointer;
        }
        
        .range-value {
            font-size: 12px;
            margin-left: 5px;
            color: #8e8e8e;
            min-width: 30px;
            text-align: right;
        }
        
        /* Improved model info container */
        #model-info-container {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(20, 22, 26, 0.85);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 60;
            color: #e0e0e0;
            font-size: 14px;
            display: none;
            max-width: calc(100vw - 300px);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            border: 1px solid #363c46;
            backdrop-filter: blur(5px);
        }
        
        /* GitHub attribution */
        #github-link {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #aaa;
            font-size: 12px;
            text-decoration: none;
            display: flex;
            align-items: center;
            background-color: rgba(20, 22, 26, 0.7);
            padding: 8px 12px;
            border-radius: 20px;
            transition: all 0.2s ease;
            z-index: 50;
        }
        
        #github-link:hover {
            color: #fff;
            background-color: rgba(20, 22, 26, 0.9);
        }
        
        #github-link svg {
            margin-right: 6px;
            vertical-align: middle;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #controls-panel {
                padding: 12px 15px;
            }
            
            #model-info-container {
                max-width: calc(100vw - 200px);
            }
        }
    </style>
</head>
<body>
    <!-- Loading container -->
    <div id="loading-container">
        <div id="loading-text"></div>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
    </div>
    
    <!-- Drop zone text -->
    <div id="drop-zone-text">Drop .drc (mesh or point cloud) or .glb file here</div>

    <!-- Model info container -->
    <div id="model-info-container">
        Current Model: <span id="current-model-name"></span>
    </div>

    <!-- Controls panel -->
    <div id="controls-panel" style="display: none;"> <!-- Hidden until model loads -->
        <div id="controls-panel-header">
            <h3>Viewer Controls</h3>
            <button id="toggle-controls-panel-collapse" title="Toggle controls panel">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
            </button>
        </div>
        <div id="controls-panel-content">
            <div class="control-section">
                <h4>Display</h4>
                <label><input type="checkbox" id="toggle-backfaceculling" checked> Backface Culling</label>
            </div>
            
            <div class="control-section">
                <h4>Background</h4>
                <label>
                    <select id="background-type">
                        <option value="color">Solid Color</option>
                        <option value="hdr">HDR</option>
                    </select>
                </label>
                <div id="background-color-controls"> <!-- Visibility will be controlled by JS -->
                    <label>
                        <input type="color" id="background-color" value="#1e2228">
                    </label>
                </div>
            </div>
        </div>
    </div>
    
    <!-- GitHub attribution -->
    <a href="https://github.com/morrisfranken/drc-viewer" target="_blank" id="github-link">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
        </svg>
        DRC Viewer on GitHub
    </a>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js'; // Added for HDR
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; // Added for GLB support

        let scene, camera, renderer, controls, directionalLight, modelMesh, ambientLight, hemisphereLight;
        // let gradientTexture; // Removed gradientTexture
        const loadingContainer = document.getElementById('loading-container');
        const loadingText = document.getElementById('loading-text');
        const progressBar = document.getElementById('progress-bar');
        const dropZoneText = document.getElementById('drop-zone-text');
        const controlsPanel = document.getElementById('controls-panel');
        const modelInfoContainer = document.getElementById('model-info-container');
        const currentModelNameSpan = document.getElementById('current-model-name');

        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        dracoLoader.setDecoderConfig({ type: 'wasm' });
        
        // Initialize GLTFLoader with DRACOLoader for Draco-encoded GLB files
        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);

        let isElectronLoadingFile = false; // Flag for Electron file loading state
        
        // Function to center a model at the origin using its bounding box
        function centerModel(object) {
            const boundingBox = new THREE.Box3().setFromObject(object);
            const center = boundingBox.getCenter(new THREE.Vector3());
            object.position.sub(center); // Move the object so its geometric center is at the origin

            if (controls) {
                controls.target.set(0, 0, 0); // Aim controls at the new center (origin)
                controls.update();
            }
        }
        
        function init() {
            // Create gradient texture - REMOVED
            // gradientTexture = createGradientTexture();
            
            // Scene
            scene = new THREE.Scene();
            // scene.background is set in setupUIControls or updateBackgroundType based on localStorage

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Added for HDR
            renderer.toneMappingExposure = 1; // Added for HDR
            document.body.appendChild(renderer.domElement);

            // Controls - Fix for sluggish movement
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false; // Disable damping for immediate response
            controls.screenSpacePanning = false;
            controls.zoomToCursor = false; // Prevent rotation when zooming
            controls.addEventListener('change', renderScene);

            // Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.9);
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            setupDragAndDrop();
            setupUIControls(); // This will now also load settings
            updateBackgroundType(); // Apply initial background based on loaded settings

            // Electron: Listen for file path from main process
            if (window.electronAPI && typeof window.electronAPI.onLoadFile === 'function') {
                window.electronAPI.onLoadFile(async (filePath) => {
                    isElectronLoadingFile = true;
                    console.log('Renderer process: Received file path via IPC:', filePath);
                    document.title = `Draco Viewer - ${filePath.split(/[\/\\]/).pop()}`;
                    updateLoadingProgress(`Reading file: ${filePath}...`, 0); // Initial message for IPC load
                    try {
                        console.log('Renderer process: Requesting file content for:', filePath);
                        const result = await window.electronAPI.readFileContent(filePath);
                        console.log('Renderer process: Received result from readFileContent for:', filePath, 'Success:', result.success);

                        if (result.success && result.data) {
                            const receivedBuffer = result.data;
                            
                            // Verify that we received valid buffer data
                            if (!receivedBuffer || !receivedBuffer.buffer) {
                                console.error('Renderer process: Invalid buffer received:', receivedBuffer);
                                showError('Invalid file data received');
                                isElectronLoadingFile = false;
                                return;
                            }
                            
                            console.log('Renderer process: Buffer received:', 
                                        'byteLength:', receivedBuffer.byteLength,
                                        'type:', Object.prototype.toString.call(receivedBuffer));
                            
                            const arrayBuffer = receivedBuffer.buffer.slice(
                                receivedBuffer.byteOffset,
                                receivedBuffer.byteOffset + receivedBuffer.byteLength
                            );
                            console.log('Renderer process: File content read and converted to ArrayBuffer, length:', arrayBuffer.byteLength);
                            
                            // Determine which loader to use based on file extension
                            const fileName = filePath.toLowerCase();
                            if (fileName.endsWith('.drc')) {
                                loadDracoModel(arrayBuffer, filePath);
                            } else if (fileName.endsWith('.glb')) {
                                loadGLBModel(arrayBuffer, filePath);
                            } else {
                                showError(`Unsupported file format: ${filePath}`);
                                isElectronLoadingFile = false;
                            }
                        } else {
                            showError(`Error reading file content: ${result.error || 'Unknown error'}`);
                            isElectronLoadingFile = false; // Reset flag on error
                        }
                    } catch (error) {
                        console.error('Renderer process: Error in onLoadFile processing:', error);
                        showError(`Error processing file: ${error.message}`);
                        isElectronLoadingFile = false; // Reset flag on error
                    }
                });
                
                setTimeout(() => {
                    // Show initial message if no model, Electron isn't loading, and HDR isn't loading
                    if (!modelMesh && !isElectronLoadingFile && 
                        (!loadingText.innerHTML || !loadingText.innerHTML.includes('Loading HDR'))) {
                        updateLoadingProgress('<h3>Welcome to Draco Viewer</h3><p class="supported-formats">Drag & drop your 3D models here to begin.</p><div class="supported-formats">Supported: <span class="format">.drc</span> <span class="format">.glb</span></div><div class="format-info">View Draco compressed meshes, point clouds, and GLB/glTF files with textures.</div>', 0);
                    }
                }, 300); // Delay to allow other initial processes to set messages

            } else {
                // Fallback for non-Electron environment
                console.warn("Electron API not found. Running in browser mode. Please drag & drop a .drc file.");
                if (!modelMesh && localStorage.getItem('drcViewer-backgroundType') !== 'hdr') {
                    updateLoadingProgress('<h3>Welcome to Draco Viewer</h3><p class="supported-formats">Drag & drop your 3D models here to begin.</p><div class="supported-formats">Supported: <span class="format">.drc</span> <span class="format">.glb</span></div><div class="format-info">View Draco compressed meshes, point clouds, and GLB/glTF files with textures.</div>', 0);
                }
            }

            window.addEventListener('resize', onWindowResize, false);
        }

        function updateLoadingProgress(text, percentage) {
            loadingContainer.style.display = 'block';
            loadingText.innerHTML = text; // Changed from innerText to innerHTML
            progressBar.style.width = percentage + '%';
        }

        function hideLoadingIndicator() {
            if (modelMesh) {
                // Model is loaded and ready
                loadingContainer.style.display = 'none';
                controlsPanel.style.display = 'block';
                // Apply collapsed state when panel is shown
                const collapseButton = document.getElementById('toggle-controls-panel-collapse');
                const controlsContent = document.getElementById('controls-panel-content');
                if (collapseButton && controlsContent) {
                    const isCollapsed = localStorage.getItem('drcViewer-controlsCollapsed') === 'true';
                    if (isCollapsed) {
                        controlsContent.classList.add('collapsed');
                        collapseButton.classList.add('collapsed');
                    } else {
                        controlsContent.classList.remove('collapsed');
                        collapseButton.classList.remove('collapsed');
                    }
                }
            } else {
                // No model is loaded (or not yet ready)
                controlsPanel.style.display = 'none'; // Always hide controls if no model

                if (isElectronLoadingFile) {
                    // Electron is attempting to load a file. Its progress messages should be displayed.
                    // Do not hide loadingContainer or show a generic prompt.
                    // Ensure loadingContainer is visible if it was showing Electron's progress.
                    if (loadingContainer.style.display === 'none' && 
                        (loadingText.innerHTML.includes('Reading file') || loadingText.innerHTML.includes('Decoding model'))) {
                         loadingContainer.style.display = 'block'; // Re-show if accidentally hidden
                    }
                } else {
                    // No Electron file loading, and no model.
                    // Show the generic "Drag & drop" prompt, unless HDR is actively loading.
                    if (!loadingText.innerHTML || !loadingText.innerHTML.includes('Loading HDR')) {
                        updateLoadingProgress('<h3>Welcome to Draco Viewer</h3><p class="supported-formats">Drag & drop your 3D models here to begin.</p><div class="supported-formats">Supported: <span class="format">.drc</span> <span class="format">.glb</span></div><div class="format-info">View Draco compressed meshes, point clouds, and GLB/glTF files with textures.</div>', 0);
                        loadingContainer.style.display = 'block'; // Ensure prompt is visible
                    }
                }
            }
        }

        function showError(message) {
            loadingContainer.style.display = 'block'; // Ensure loading container is visible for errors
            loadingText.innerText = message;
            progressBar.style.width = '0%';
            progressBar.style.backgroundColor = '#F44336'; // Optional: Error color for progress bar
            console.error(message);
            controlsPanel.style.display = 'none';
            modelInfoContainer.style.display = 'none';
        }
        
        function clearScene() {
            if (modelMesh) {
                scene.remove(modelMesh);
                
                // Handle geometry disposal based on model type
                if (modelMesh instanceof THREE.Mesh || modelMesh instanceof THREE.Points) {
                    if (modelMesh.geometry) modelMesh.geometry.dispose();
                    if (modelMesh.material) {
                        if (Array.isArray(modelMesh.material)) {
                            modelMesh.material.forEach(m => m.dispose());
                        } else {
                            modelMesh.material.dispose();
                        }
                    }
                } else {
                    // For GLB scenes, traverse and dispose all materials and geometries
                    modelMesh.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
                
                modelMesh = null;
            }
            
            // Hide point size controls
            const pointSizeSection = document.getElementById('point-size-section');
            if (pointSizeSection) {
                pointSizeSection.style.display = 'none';
            }
            
            modelInfoContainer.style.display = 'none';
            currentModelNameSpan.textContent = '';
            currentModelNameSpan.title = ''; // Clear tooltip
            document.title = "Draco Viewer";
        }

        function loadDracoModel(source, displayInfo) {
            clearScene();
            progressBar.style.backgroundColor = '#4CAF50';
            
            // const loadingMessage = displayInfo ? `Preparing to load ${displayInfo.split(/[\/\\]/).pop()}...` : 'Preparing to load...';
            // updateLoadingProgress(loadingMessage, 0); // This might be too early if called from Electron IPC which already set a message

            if(displayInfo) {
                let titleName = displayInfo;
                if (displayInfo.includes('/') || displayInfo.includes('\\')) { 
                    titleName = displayInfo.split(/[\/\\]/).pop();
                }
                document.title = `Draco Viewer - ${titleName}`;
            }

            const handleModelLoadSuccess = function (geometry) {
                updateLoadingProgress('Decoding complete. Building scene...', 100);
                
                setTimeout(() => {
                    if (!geometry) {
                        handleModelLoadError("Failed to decode model: Geometry is null.");
                        return;
                    }
                    
                    // Check if it's a point cloud
                    const isPCloud = isPointCloud(geometry);
                    
                    // Handle colors if available in geometry
                    let material;
                    if (geometry.attributes.color) {
                        if (isPCloud) {
                            material = new THREE.PointsMaterial({
                                size: 0.01,
                                vertexColors: true
                            });
                        } else {
                            material = createModelMaterial();
                            material.vertexColors = true;
                        }
                    } else {
                        if (isPCloud) {
                            material = new THREE.PointsMaterial({
                                size: 0.01,
                                color: 0xd1d1d1
                            });
                        } else {
                            material = createModelMaterial();
                        }
                    }
                    
                    // For point clouds, use Points instead of Mesh
                    if (isPCloud) {
                        geometry.computeVertexNormals();
                        modelMesh = new THREE.Points(geometry, material);
                        console.log('Loaded as point cloud');
                        
                        // Show point size controls for point clouds
                        const pointSizeSection = document.getElementById('point-size-section');
                        if (pointSizeSection) {
                            pointSizeSection.style.display = 'block';
                        }
                    } else {
                        geometry.computeVertexNormals();
                        modelMesh = new THREE.Mesh(geometry, material);
                        console.log('Loaded as mesh');
                        
                        // Hide point size controls for regular meshes
                        const pointSizeSection = document.getElementById('point-size-section');
                        if (pointSizeSection) {
                            pointSizeSection.style.display = 'none';
                        }
                    }
                    scene.add(modelMesh);

                    // ... (rest of existing model setup: bounding box, scaling, camera, etc.)
                    geometry.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geometry.boundingBox.getCenter(center);
                    modelMesh.position.sub(center);

                    const size = new THREE.Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDimInitial = Math.max(size.x, size.y, size.z) || 1;
                    const scaleFactor = 2 / maxDimInitial;
                    modelMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    modelMesh.updateMatrixWorld(true);

                    const box = new THREE.Box3().setFromObject(modelMesh);
                    const modelSize = new THREE.Vector3();
                    box.getSize(modelSize);
                    const modelCenter = new THREE.Vector3();
                    box.getCenter(modelCenter);

                    controls.target.copy(modelCenter);

                    const fov = camera.fov * (Math.PI / 180);
                    const effectiveModelSize = Math.max(modelSize.x, modelSize.y, modelSize.z) || 1;
                    const distance = (effectiveModelSize / 2) / Math.tan(fov / 2);

                    camera.position.set(
                        modelCenter.x,
                        modelCenter.y + effectiveModelSize * 0.3,
                        modelCenter.z + distance * 1.5
                    );
                    camera.lookAt(modelCenter);

                    controls.minDistance = effectiveModelSize / 10;
                    controls.maxDistance = effectiveModelSize * 10;
                    controls.update();

                    directionalLight.target = modelMesh;
                    // END of model setup
                    
                    isElectronLoadingFile = false; // Reset flag
                    hideLoadingIndicator(); // Call this when model is actually ready and processed

                    if (displayInfo) {
                        currentModelNameSpan.textContent = displayInfo;
                        currentModelNameSpan.title = displayInfo;
                        modelInfoContainer.style.display = 'block';
                    } else if (typeof source === 'string' && source !== '_active_model.drc') {
                        currentModelNameSpan.textContent = source;
                        currentModelNameSpan.title = source;
                        modelInfoContainer.style.display = 'block';
                    } else {
                        modelInfoContainer.style.display = 'none';
                    }
                    renderScene();
                }, 10);
            };

            const onModelDownloadProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    const percentComplete = xhr.loaded / xhr.total * 100;
                    updateLoadingProgress(`Downloading model... (${Math.round(percentComplete)}%)`, percentComplete);
                } else {
                    updateLoadingProgress('Downloading model... (progress unknown)', 0);
                }
            };
            
            const handleModelLoadError = function (error) {
                let errorMessage = 'Error loading Draco model.';
                if (error instanceof Error) {
                    errorMessage += ` ${error.message}`;
                } else if (typeof error === 'string') {
                    errorMessage += ` ${error}`;
                } else if (error && error.target && error.target.statusText && error.target.status !== 200) {
                    errorMessage += ` Network error: ${error.target.status} ${error.target.statusText}`;
                } else {
                    errorMessage += ` An unknown error occurred.`;
                }
                console.error('DracoLoader error details:', error);
                isElectronLoadingFile = false; // Reset flag on error
                showError(errorMessage); // showError handles UI for loading indicator
                if (dracoLoader) dracoLoader.dispose();
            };

            if (typeof source === 'string' && source.trim() !== '') {
                updateLoadingProgress(`Downloading ${displayInfo ? displayInfo.split(/[\/\\]/).pop() : source}...`, 0);
                const cacheBustedSource = source + '?v=' + new Date().getTime();
                dracoLoader.load(cacheBustedSource, handleModelLoadSuccess, onModelDownloadProgress, handleModelLoadError);
            } else if (source instanceof ArrayBuffer) {
                updateLoadingProgress('Decoding model from file...', 50); // Message for parsing from buffer
                try {
                    dracoLoader.parse(
                        source,
                        function (geometry) { 
                            if (geometry) {
                                handleModelLoadSuccess(geometry);
                            } else {
                                handleModelLoadError(new Error("DRACOLoader.parse returned null or invalid geometry."));
                            }
                        },
                        function (parseError) { 
                            console.error('DracoLoader.parse error:', parseError);
                            handleModelLoadError(parseError || new Error("DRACOLoader.parse failed."));
                        }
                    );
                } catch (e) {
                    console.error('Unexpected error during dracoLoader.parse setup:', e);
                    handleModelLoadError(e);
                } 
                // dracoLoader.dispose() for parse is typically not needed unless re-instantiating loader per parse
            } else if (!source) {
                handleModelLoadError("No model source provided to loadDracoModel.");
            }
        }

        // New function to load GLB models with support for Draco compression
        function loadGLBModel(source, displayInfo) {
            clearScene();
            progressBar.style.backgroundColor = '#4CAF50';
            
            if(displayInfo) {
                let titleName = displayInfo;
                if (displayInfo.includes('/') || displayInfo.includes('\\')) { 
                    titleName = displayInfo.split(/[\/\\]/).pop();
                }
                document.title = `Draco Viewer - ${titleName}`;
                currentModelNameSpan.textContent = titleName;
                currentModelNameSpan.title = displayInfo;
                modelInfoContainer.style.display = 'block';
            }

            const handleGLBLoadSuccess = function (gltf) {
                updateLoadingProgress('GLB loaded. Building scene...', 100);
                
                setTimeout(() => {
                    if (!gltf || !gltf.scene) {
                        handleGLBLoadError("Failed to load GLB: Model is null or has no scene.");
                        return;
                    }
                    
                    // Set the entire GLB scene as the model mesh
                    modelMesh = gltf.scene;
                    
                    // Hide point size controls for GLB models
                    const pointSizeSection = document.getElementById('point-size-section');
                    if (pointSizeSection) {
                        pointSizeSection.style.display = 'none';
                    }
                    
                    // Set shadow properties for all meshes in the scene
                    modelMesh.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Apply backface culling setting if material exists
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.side = document.getElementById('toggle-backfaceculling').checked ? THREE.FrontSide : THREE.DoubleSide;
                                    });
                                } else {
                                    child.material.side = document.getElementById('toggle-backfaceculling').checked ? THREE.FrontSide : THREE.DoubleSide;
                                }
                            }
                        }
                    });
                    
                    scene.add(modelMesh);
                    
                    // Center the model at origin
                    centerModel(modelMesh);
                    
                    // Calculate bounding box for camera positioning
                    const box = new THREE.Box3().setFromObject(modelMesh);
                    const modelSize = new THREE.Vector3();
                    box.getSize(modelSize);
                    const modelCenter = new THREE.Vector3();
                    box.getCenter(modelCenter);

                    // Update controls target to model center
                    controls.target.copy(modelCenter);
                    
                    // Position camera based on model size
                    const fov = camera.fov * (Math.PI / 180);
                    const effectiveModelSize = Math.max(modelSize.x, modelSize.y, modelSize.z) || 1;
                    const distance = (effectiveModelSize / 2) / Math.tan(fov / 2);

                    camera.position.set(
                        modelCenter.x,
                        modelCenter.y + effectiveModelSize * 0.3,
                        modelCenter.z + distance * 1.5
                    );
                    camera.lookAt(modelCenter);

                    // Set camera constraints based on model size
                    controls.minDistance = effectiveModelSize / 10;
                    controls.maxDistance = effectiveModelSize * 10;
                    controls.update();
                    
                    directionalLight.target = modelMesh;
                    
                    isElectronLoadingFile = false;
                    hideLoadingIndicator();
                    renderScene();
                }, 10);
            };

            const onGLBDownloadProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    const percentComplete = xhr.loaded / xhr.total * 100;
                    updateLoadingProgress(`Downloading GLB... (${Math.round(percentComplete)}%)`, percentComplete);
                } else {
                    updateLoadingProgress('Downloading GLB... (progress unknown)', 0);
                }
            };
            
            const handleGLBLoadError = function (error) {
                let errorMessage = 'Error loading GLB model.';
                if (error instanceof Error) {
                    errorMessage += ` ${error.message}`;
                } else if (typeof error === 'string') {
                    errorMessage += ` ${error}`;
                } else if (error && error.target && error.target.statusText && error.target.status !== 200) {
                    errorMessage += ` Network error: ${error.target.status} ${error.target.statusText}`;
                } else {
                    errorMessage += ` An unknown error occurred.`;
                }
                console.error('GLTFLoader error details:', error);
                isElectronLoadingFile = false;
                showError(errorMessage);
            };

            if (typeof source === 'string' && source.trim() !== '') {
                updateLoadingProgress(`Downloading ${displayInfo ? displayInfo.split(/[\/\\]/).pop() : source}...`, 0);
                const cacheBustedSource = source + '?v=' + new Date().getTime();
                gltfLoader.load(cacheBustedSource, handleGLBLoadSuccess, onGLBDownloadProgress, handleGLBLoadError);
            } else if (source instanceof ArrayBuffer) {
                updateLoadingProgress('Parsing GLB file...', 50);
                try {
                    gltfLoader.parse(source, '', handleGLBLoadSuccess, handleGLBLoadError);
                } catch (e) {
                    console.error('Unexpected error during gltfLoader.parse setup:', e);
                    handleGLBLoadError(e);
                }
            } else if (!source) {
                handleGLBLoadError("No model source provided to loadGLBModel.");
            }
        }

        function setupDragAndDrop() {
            const body = document.body;
            body.addEventListener('dragover', function(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
                dropZoneText.style.display = 'block';
                body.style.backgroundColor = '#3a3f4a';
                if (loadingContainer) {
                    loadingContainer.style.pointerEvents = 'none';
                }
            });

            body.addEventListener('dragleave', function(event) {
                // Check if the mouse is truly leaving the body, not just moving to a child
                // With pointer-events: none on children, this check might be less critical,
                // but it's good for robustness.
                if (event.relatedTarget === null || !body.contains(event.relatedTarget)) {
                    dropZoneText.style.display = 'none';
                    body.style.backgroundColor = '#1e2228'; // Reset to original or desired non-dragover color
                    if (loadingContainer) {
                        loadingContainer.style.pointerEvents = 'auto';
                    }
                }
            });

            body.addEventListener('drop', function(event) {
                event.preventDefault();
                dropZoneText.style.display = 'none';
                body.style.backgroundColor = '#1e2228'; // Reset to original or desired non-dragover color
                if (loadingContainer) {
                    loadingContainer.style.pointerEvents = 'auto';
                }

                if (event.dataTransfer.files.length > 0) {
                    const file = event.dataTransfer.files[0];
                    const fileName = file.name.toLowerCase();
                    
                    if (fileName.endsWith('.drc')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const droppedFilename = file.name;
                            document.title = `Draco Viewer - ${droppedFilename}`;
                            updateLoadingProgress(`Loading ${droppedFilename}...`, 0);
                            loadDracoModel(e.target.result, droppedFilename); 
                        };
                        reader.onerror = function(e) {
                            showError('Error reading dropped file.');
                        }
                        reader.readAsArrayBuffer(file);
                    } else if (fileName.endsWith('.glb')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const droppedFilename = file.name;
                            document.title = `Draco Viewer - ${droppedFilename}`;
                            updateLoadingProgress(`Loading ${droppedFilename}...`, 0);
                            loadGLBModel(e.target.result, droppedFilename);
                        };
                        reader.onerror = function(e) {
                            showError('Error reading dropped file.');
                        }
                        reader.readAsArrayBuffer(file);
                    } else {
                        showError('Please drop a .drc or .glb file.');
                    }
                }
            });

            // Add a global dragend listener to handle cases where drag is cancelled
            document.addEventListener('dragend', function(event) {
                dropZoneText.style.display = 'none';
                body.style.backgroundColor = '#1e2228'; // Reset to original or desired non-dragover color
                if (loadingContainer) {
                    loadingContainer.style.pointerEvents = 'auto';
                }
            }, false);
        }

        function isPointCloud(geometry) {
            // Check if it's a point cloud by detecting if there are no indices (no faces)
            // BufferGeometry with no indices typically represents a point cloud
            return !geometry.index && geometry.attributes.position;
        }
        
        function createModelMaterial() {
            const material = new THREE.MeshStandardMaterial({
                color: 0xd1d1d1, // Keep a default color
                metalness: 0.1,
                roughness: 0.5,
                side: document.getElementById('toggle-backfaceculling').checked ? THREE.FrontSide : THREE.DoubleSide
            });
            
            return material;
        }
        
        function updateBackfaceCulling() {
            if (modelMesh) {
                const isChecked = document.getElementById('toggle-backfaceculling').checked;
                // Only apply side property if it's a mesh, not points
                if (modelMesh instanceof THREE.Mesh) {
                    modelMesh.material.side = isChecked ? THREE.FrontSide : THREE.DoubleSide;
                    modelMesh.material.needsUpdate = true;
                }
                localStorage.setItem('drcViewer-backfaceCulling', isChecked);
                renderScene();
            }
        }
        
        function updateBackgroundType() {
            const bgType = document.getElementById('background-type').value;
            const bgColorInput = document.getElementById('background-color');
            const bgColorControls = document.getElementById('background-color-controls');
            
            localStorage.setItem('drcViewer-backgroundType', bgType);
            
            scene.environment = null;
            renderer.toneMapping = THREE.NoToneMapping;

            switch(bgType) {
                case 'color':
                    const savedColor = localStorage.getItem('drcViewer-backgroundColor') || '#1e2228';
                    bgColorInput.value = savedColor; // Ensure color picker shows the loaded/default color
                    scene.background = new THREE.Color(savedColor);
                    bgColorControls.style.display = 'block';
                    break;
                case 'hdr':
                    bgColorControls.style.display = 'none';
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1;
                    // Only show HDR loading message if Electron isn't primary or its message isn't active
                    if (!isElectronLoadingFile || 
                        (isElectronLoadingFile && !modelMesh && 
                         !loadingText.innerHTML.includes('Reading file') && 
                         !loadingText.innerHTML.includes('Decoding model'))) {
                        updateLoadingProgress('Loading HDR background...', 0);
                    }
                    new RGBELoader()
                        .setPath('https://threejs.org/examples/textures/equirectangular/')
                        .load('royal_esplanade_1k.hdr', function (texture) {
                            texture.mapping = THREE.EquirectangularReflectionMapping;
                            scene.background = texture;
                            scene.environment = texture;
                            // Show HDR loaded message briefly, respecting Electron loading state
                            if (!isElectronLoadingFile || (isElectronLoadingFile && !modelMesh && !loadingText.innerHTML.includes('Decoding model'))) {
                                updateLoadingProgress('HDR background loaded.', 100);
                            }
                            setTimeout(() => {
                                hideLoadingIndicator(); // Will respect isElectronLoadingFile
                                renderScene();
                            }, 500);
                        }, 
                        (xhr) => { // onProgress for HDR
                            if (!isElectronLoadingFile || (isElectronLoadingFile && !modelMesh && !loadingText.innerHTML.includes('Decoding model'))) {
                                if (xhr.lengthComputable) {
                                    const percentComplete = xhr.loaded / xhr.total * 100;
                                    updateLoadingProgress(`Loading HDR... (${Math.round(percentComplete)}%)`, percentComplete);
                                } else {
                                    updateLoadingProgress('Loading HDR...', 0);
                                }
                            }
                        },
                        (error) => { // onError for HDR
                            console.error('Error loading HDR:', error);
                            showError('Failed to load HDR background. Reverting to solid color.');
                            document.getElementById('background-type').value = 'color';
                            localStorage.setItem('drcViewer-backgroundType', 'color');
                            const fallbackColor = localStorage.getItem('drcViewer-backgroundColor') || '#1e2228';
                            scene.background = new THREE.Color(fallbackColor);
                            bgColorControls.style.display = 'block';
                            renderer.toneMapping = THREE.NoToneMapping;
                            // hideLoadingIndicator might be needed if showError doesn't fully cover the state
                            // but showError should be sufficient as it manages loadingContainer and controlsPanel.
                            if (!modelMesh) controlsPanel.style.display = 'none';
                            renderScene();
                        });
                    break;
            }
            renderScene();
        }

        function updateBackgroundColor() {
            const color = document.getElementById('background-color').value;
            localStorage.setItem('drcViewer-backgroundColor', color);
            if (document.getElementById('background-type').value === 'color') {
                scene.background = new THREE.Color(color);
                renderScene();
            }
        }

        function setupUIControls() {
            // Point size control section for point clouds
            const controlsContent = document.getElementById('controls-panel-content');
            
            // Add point size section if it doesn't exist
            if (!document.getElementById('point-size-section')) {
                const pointSizeSection = document.createElement('div');
                pointSizeSection.className = 'control-section';
                pointSizeSection.id = 'point-size-section';
                pointSizeSection.style.display = 'none'; // Hide by default, shown only for point clouds
                pointSizeSection.innerHTML = `
                    <h4>Point Cloud</h4>
                    <div>
                        <label for="point-size">Point Size: <span class="range-value" id="point-size-value">0.01</span></label>
                        <input type="range" id="point-size" min="0.001" max="0.05" step="0.001" value="0.01">
                    </div>
                `;
                controlsContent.appendChild(pointSizeSection);
                
                const pointSizeSlider = document.getElementById('point-size');
                pointSizeSlider.addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    document.getElementById('point-size-value').textContent = value.toFixed(3);
                    if (modelMesh && modelMesh instanceof THREE.Points) {
                        modelMesh.material.size = value;
                        modelMesh.material.needsUpdate = true;
                        renderScene();
                    }
                });
            }
            
            // Backface culling toggle
            const backfaceCullingToggle = document.getElementById('toggle-backfaceculling');
            const savedBackfaceCulling = localStorage.getItem('drcViewer-backfaceCulling');
            if (savedBackfaceCulling !== null) {
                backfaceCullingToggle.checked = (savedBackfaceCulling === 'true');
            }
            backfaceCullingToggle.addEventListener('change', updateBackfaceCulling);
            
            // Background type
            const backgroundType = document.getElementById('background-type');
            const backgroundColorControls = document.getElementById('background-color-controls');
            const savedBackgroundType = localStorage.getItem('drcViewer-backgroundType');
            if (savedBackgroundType) {
                backgroundType.value = savedBackgroundType;
            }
            
            backgroundType.addEventListener('change', updateBackgroundType);
            
            // Initialize visibility of color picker based on loaded or default selection
            if (backgroundType.value === 'color') {
                backgroundColorControls.style.display = 'block';
            } else {
                backgroundColorControls.style.display = 'none';
            }

            // Background color
            const backgroundColorInput = document.getElementById('background-color');
            const savedBackgroundColor = localStorage.getItem('drcViewer-backgroundColor');
            if (savedBackgroundColor) {
                backgroundColorInput.value = savedBackgroundColor;
            }
            backgroundColorInput.addEventListener('input', updateBackgroundColor);
            backgroundColorInput.addEventListener('change', updateBackgroundColor);

            // Collapsible panel setup
            const collapseButton = document.getElementById('toggle-controls-panel-collapse');
            // Don't reassign controlsContent since it's already defined as a constant above
            
            if (collapseButton && controlsContent) {
                const initialCollapsedState = localStorage.getItem('drcViewer-controlsCollapsed') === 'true';
                if (initialCollapsedState) {
                    controlsContent.classList.add('collapsed');
                    // collapseButton.textContent = 'Expand';
                    collapseButton.classList.add('collapsed');
                } else {
                    controlsContent.classList.remove('collapsed');
                    // collapseButton.textContent = 'Collapse';
                    collapseButton.classList.remove('collapsed');
                }

                collapseButton.addEventListener('click', () => {
                    controlsContent.classList.toggle('collapsed');
                    const isCurrentlyCollapsed = controlsContent.classList.contains('collapsed');
                    if (isCurrentlyCollapsed) {
                        // collapseButton.textContent = 'Expand';
                        collapseButton.classList.add('collapsed');
                        localStorage.setItem('drcViewer-controlsCollapsed', 'true');
                    } else {
                        // collapseButton.textContent = 'Collapse';
                        collapseButton.classList.remove('collapsed');
                        localStorage.setItem('drcViewer-controlsCollapsed', 'false');
                    }
                });
            }

            // Initial application of settings if model already exists (e.g. page reload with model)
            if (modelMesh) {
                updateBackfaceCulling(); 
            }
            // updateBackgroundType(); // Called in init after setupUIControls
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderScene();
        }

        function renderScene() {
            if (directionalLight && camera) {
                directionalLight.position.copy(camera.position);
                if (directionalLight.target && directionalLight.target !== scene) {
                     directionalLight.target.updateMatrixWorld();
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>